优化索引速度
1.使用批量(bulk)请求
	为了知道批量请求的最佳大小，应该在具有单个分片的单个节点上运行基准测试。首先尝试一次索引100个文档，然后索引200个，再索引400个，依此类推。在每次基准测试运行中，批量请求中的文档数量加倍。当索引创建速度开始趋于平稳时，便知道已达到批量请求数据的最佳大小。当大量请求同时发送时，太大的批量请求可能会使群集内存处于压力下，因此要避免每个请求超过几十兆字节，使每个请求执行得更好。

2.使用多线程(threads/workers)发送数据
	单线程不太可能最大化elasticsearch集群的索引容量。为了调用起集群的资源，应该使用多线程或进程发送数据。除了更好地利用群集的资源之外，这还应有助于降低每个fsync(同步)的成本。
	但要注意监控429响应码(TOO_MANY_REQUESTS (429) response codes (EsRejectedExecutionException with the Java client))，它意味着集群无法跟上请求的速度。发生这种情况时，您应该暂停索引，然后再重试，最好使用随机指数退避。
	同bulk，需要通过测试来确定最佳情况。可以通过逐渐增加线程数量直到群集上的IO或CPU达到饱和来测试这一点。

3.取消设置或增加刷新间隔(refresh interval)
	更改时对搜索可见的刷新操作非常昂贵，并且在正在进行创建索引时进行调用会影响索引速度。
	默认情况下，Elasticsearch会定期每秒刷新一次索引，但仅在最近30秒内已收到搜索请求的索引上进行刷新。
	如果建立索引时没有或很少搜索流量，并想要优化索引速度，则这是最佳设置。此行为仅在不执行搜索时优化批量索引，退出此行为请显示设置刷新间隔。
	增加index.refresh_interval到一个较大的值，可能有助于提高索引速度。

4.初始化加载时禁用refresh和replica
	一次加载大量数据，应设置index.refresh_interval=-1和index.number_of_replicas=0。这将使索引暂时处于危险之中，因为任何分片的丢失都会导致数据丢失，但是同时索引会更快，因为文档只会被索引一次。初始加载完成后，您可以设置index.refresh_interval并index.number_of_replicas返回其原始值。

5.禁用swapping
	应该确保操作系统没有swapping out进程。

6.给filesystem设置缓存

7.使用自动生成的ID
	显示ID时，Elasticsearch会检查具有相同ID的文档是否已存在于同一分片中，这是一项昂贵的操作，并且随着索引的增长而变得更加昂贵。

8.使用更快更好的硬件

9.索引缓冲区index_buffer_size
	确保 indices.memory.index_buffer_size有足够大的空间，以使每个分片在执行重索引时最多提供512 MB索引缓冲区（除此之外，索引性能通常不会提高）。Elasticsearch接受该设置（占Java堆的百分比或绝对字节大小），并将其用作所有活动分片上的共享缓冲区。非常活跃的分片自然会比执行轻量级索引的分片更多地使用此缓冲区。
	默认值10%通常足够大：例如，如果给JVM 10GB的内存，它将为索引缓冲区提供1GB的内存，这足以容纳两个大量建立索引的分片。











